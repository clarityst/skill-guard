#!/usr/bin/env node
import { Command } from "commander";
import fs from "node:fs";
import path from "node:path";
import os from "node:os";
import crypto from "node:crypto";
import { spawnSync } from "node:child_process";
import fg from "fast-glob";
import ignore from "ignore";

const program = new Command();

function run(cmd, args, opts = {}) {
  return spawnSync(cmd, args, {
    stdio: "pipe",
    encoding: "utf8",
    shell: process.platform === "win32",
    ...opts,
  });
}

function findClawhubCmd() {
  // Always use npx on Windows for consistent argument forwarding.
  // This matches: npx clawhub install <slug> --version <v> --force
  if (process.platform === "win32") return { cmd: "npx", prefixArgs: ["clawhub"] };

  const which = "which";
  const r = run(which, ["clawhub"]);
  if (r.status === 0) return { cmd: "clawhub", prefixArgs: [] };
  return { cmd: "npx", prefixArgs: ["clawhub"] };
}

function readJSON(p) {
  return JSON.parse(fs.readFileSync(p, "utf8"));
}

function exists(p) {
  try {
    fs.accessSync(p);
    return true;
  } catch {
    return false;
  }
}

function hashFile(p) {
  const h = crypto.createHash("sha256");
  h.update(fs.readFileSync(p));
  return h.digest("hex");
}

function listFiles(rootDir) {
  const ig = ignore().add([
    ".DS_Store",
    "**/.git/**",
    "**/.clawhub/**",
    "**/node_modules/**",
  ]);
  const all = fg.sync(["**/*"], { cwd: rootDir, dot: true, onlyFiles: true });
  return all.filter((rel) => !ig.ignores(rel));
}

function diffSummary(oldDir, newDir) {
  const oldFiles = new Set(listFiles(oldDir));
  const newFiles = new Set(listFiles(newDir));

  const added = [];
  const removed = [];
  const changed = [];

  for (const f of newFiles) if (!oldFiles.has(f)) added.push(f);
  for (const f of oldFiles) if (!newFiles.has(f)) removed.push(f);

  for (const f of newFiles) {
    if (!oldFiles.has(f)) continue;
    const a = path.join(oldDir, f);
    const b = path.join(newDir, f);
    if (hashFile(a) !== hashFile(b)) changed.push(f);
  }

  return { added, removed, changed };
}

function riskScan(dir) {
  // Lightweight heuristics (not antivirus)
  const patterns = [
    { id: "EXEC_HINT", re: /\b(exec|spawn|powershell|bash|sh|cmd\.exe)\b/i, score: 3 },
    { id: "CURL_PIPE", re: /curl.+\|\s*(bash|sh)/i, score: 5 },
    { id: "WGET_PIPE", re: /wget.+\|\s*(bash|sh)/i, score: 5 },
    { id: "SECRETS_HINT", re: /\b(api[_-]?key|secret|token|authorization|bearer)\b/i, score: 3 },
    { id: "ENV_HINT", re: /\bprocess\.env\b/i, score: 3 },
    { id: "NETWORK_HINT", re: /\b(fetch|axios|http(s)?:\/\/)\b/i, score: 2 },
  ];

  const files = listFiles(dir);
  let score = 0;
  const hits = [];

  for (const rel of files) {
    const full = path.join(dir, rel);
    const buf = fs.readFileSync(full);
    if (buf.length > 300_000) continue;

    const text = buf.toString("utf8");
    if (text.includes("\u0000")) continue; // binary-ish

    for (const p of patterns) {
      if (p.re.test(text)) {
        score += p.score;
        hits.push({ rule: p.id, file: rel });
      }
    }
  }

  return { score, hits };
}

function loadLock(workdir) {
  const lockPath = path.join(workdir, ".clawhub", "lock.json");
  if (!exists(lockPath)) {
    throw new Error(
      `Could not find lockfile: ${lockPath}\n` +
        `Go to the directory where your OpenClaw skills are managed by clawhub (where .clawhub/lock.json exists).`
    );
  }
  return { lockPath, lock: readJSON(lockPath) };
}

function detectSkillsFromLock(lock) {
  // Tolerant parser: lock formats may vary
  if (Array.isArray(lock)) return lock.map((x) => x?.slug).filter(Boolean);
  if (lock?.skills && Array.isArray(lock.skills)) return lock.skills.map((x) => x?.slug).filter(Boolean);
  if (lock?.skills && typeof lock.skills === "object") return Object.keys(lock.skills);
  if (typeof lock === "object" && lock) {
    const keys = Object.keys(lock);
    return keys.filter((k) => !["version", "meta", "updatedAt"].includes(k));
  }
  return [];
}

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function installIntoTemp({ slug, version, workdirTmp }) {
  const { cmd, prefixArgs } = findClawhubCmd();

  // "version" might be an object from clawhub inspect/list; normalize to string.
  const v =
    typeof version === "string"
      ? version
      : version?.version ?? String(version);

  const args = [
    ...prefixArgs,
    "install",
    slug,
    "--version",
    v,
    "--force",
  ];

  // (optional) keep debug for now
  console.error("DEBUG install cmd:", cmd);
  console.error("DEBUG install args:", JSON.stringify(args));
  console.error("DEBUG install cwd:", workdirTmp);

  const r = run(cmd, args, { cwd: workdirTmp });
  if (r.status !== 0) {
    throw new Error(`clawhub install failed:\n${r.stderr}\n${r.stdout}`);
  }
}
function listFilesViaInspect(slug, version) {
  const { cmd, prefixArgs } = findClawhubCmd();
  const r = run(cmd, [
    ...prefixArgs,
    "inspect",
    slug,
    "--version",
    version,
    "--files",
    "--json",
  ]);

  if (r.status !== 0) {
    throw new Error(`clawhub inspect --files failed:\n${r.stderr}\n${r.stdout}`);
  }

  let data;
  try {
    data = JSON.parse(r.stdout);
  } catch {
    throw new Error(`Failed to parse JSON from clawhub inspect --files. Output:\n${r.stdout}`);
  }

  // try common shapes
  const files =
    data?.files ??
    data?.skill?.files ??
    data?.entries ??
    data?.data?.files;

  if (!Array.isArray(files)) {
    throw new Error(`Could not read files list from inspect JSON:\n${JSON.stringify(data, null, 2)}`);
  }

  // normalize to strings
  return files
    .map((f) => (typeof f === "string" ? f : f?.path))
    .filter((p) => typeof p === "string" && p.length > 0);
}

function getLatestVersionViaInspect(slug) {
  const { cmd, prefixArgs } = findClawhubCmd();
  const r = run(cmd, [...prefixArgs, "inspect", slug, "--json"]);
  if (r.status !== 0) {
    throw new Error(`clawhub inspect failed:\n${r.stderr}\n${r.stdout}`);
  }

  let data;
  try {
    data = JSON.parse(r.stdout);
  } catch {
    throw new Error(`Failed to parse JSON from clawhub inspect. Output:\n${r.stdout}`);
  }

  // tolerate different shapes
  const v =
    data?.version ??
    data?.latest?.version ??
    data?.skill?.version ??
    data?.skill?.latest?.version ??
    data?.meta?.version;

  if (typeof v !== "string" || !v.trim()) {
    throw new Error(`Could not determine version from clawhub inspect JSON:\n${JSON.stringify(data, null, 2)}`);
  }

  return v.trim();
}

function prettyPrintReport({ slug, versionNew, diff, risk }) {
  console.log(`\n=== ${slug}  ->  ${versionNew} ===`);
  console.log(`added:   ${diff.added.length}`);
  console.log(`removed: ${diff.removed.length}`);
  console.log(`changed: ${diff.changed.length}`);
  console.log(`risk score: ${risk.score}`);

  if (risk.hits.length) {
    console.log("risk hits:");
    for (const h of risk.hits.slice(0, 30)) console.log(`  - ${h.rule}  ${h.file}`);
    if (risk.hits.length > 30) console.log(`  ... +${risk.hits.length - 30} more`);
  }
}

program.name("skill-guard").description("Safety gate for ClawHub skill updates (diff + risk heuristics).");

program
  .command("check")
  .option("--workdir <path>", "workdir (default: current dir)", process.cwd())
  .option("--dir <name>", "skills dir under workdir", "skills")
  .option("--all", "check all installed skills from lockfile", false)
  .option("--slug <slug>", "check one skill")
  .option("--max-risk <n>", "block if risk score > n", "6")
  .action((opts) => {
    const workdir = path.resolve(opts.workdir);
    const { lock } = loadLock(workdir);

    const slugs = opts.all ? detectSkillsFromLock(lock) : opts.slug ? [opts.slug] : [];
    if (!slugs.length) {
      console.error("Nothing to check. Use --all or --slug <slug>.");
      process.exit(2);
    }

    const maxRisk = Number(opts.maxRisk);
    let blocked = 0;

    for (const slug of slugs) {
      const localDir = path.join(workdir, opts.dir, slug);
      if (!exists(localDir)) {
        console.log(`\n=== ${slug} ===\nSKIP: local skill directory does not exist: ${localDir}`);
        continue;
      }

      const versionNew = getLatestVersionViaInspect(slug);

      const tmp = fs.mkdtempSync(path.join(os.tmpdir(), "skill-guard-"));
      ensureDir(path.join(tmp, opts.dir));

      const files = listFilesViaInspect(slug, versionNew);

console.log(`\n=== ${slug} v${versionNew} ===`);
console.log(files.slice(0, 50).join("\n"));
console.log(`... total files: ${files.length}`);

continue;

      const newDir = path.join(tmp, opts.dir, slug);
      const diff = diffSummary(localDir, newDir);
      const risk = riskScan(newDir);

      prettyPrintReport({ slug, versionNew, diff, risk });

      if (risk.score > maxRisk) {
        console.log(`BLOCK: risk score ${risk.score} > ${maxRisk}`);
        blocked++;
      } else {
        console.log("OK");
      }
    }

    process.exit(blocked ? 1 : 0);
  });

program
  .command("update")
  .option("--workdir <path>", "workdir (default: current dir)", process.cwd())
  .option("--dir <name>", "skills dir under workdir", "skills")
  .option("--all", "update all installed skills", false)
  .option("--slug <slug>", "update one skill")
  .option("--max-risk <n>", "block if risk score > n", "6")
  .action((opts) => {
    const workdir = path.resolve(opts.workdir);
    const { lock } = loadLock(workdir);

    const slugs = opts.all ? detectSkillsFromLock(lock) : opts.slug ? [opts.slug] : [];
    if (!slugs.length) {
      console.error("Nothing to update. Use --all or --slug <slug>.");
      process.exit(2);
    }

    const maxRisk = Number(opts.maxRisk);
    let blocked = 0;

    for (const slug of slugs) {
      const localDir = path.join(workdir, opts.dir, slug);
      if (!exists(localDir)) continue;

      const versionNew = getLatestVersionViaInspect(slug);

      const tmp = fs.mkdtempSync(path.join(os.tmpdir(), "skill-guard-"));
      ensureDir(path.join(tmp, opts.dir));

      installIntoTemp({ slug, version: versionNew, workdirTmp: tmp });

      const newDir = path.join(tmp, opts.dir, slug);
      const diff = diffSummary(localDir, newDir);
      const risk = riskScan(newDir);

      prettyPrintReport({ slug, versionNew, diff, risk });

      if (risk.score > maxRisk) {
        console.log(`BLOCK: risk score ${risk.score} > ${maxRisk}`);
        blocked++;
      }
    }

    if (blocked) process.exit(1);

    const { cmd, prefixArgs } = findClawhubCmd();
    const base = [...prefixArgs, "update", "--workdir", workdir, "--dir", opts.dir, "--no-input", "--force"];

    const r = opts.all
      ? spawnSync(cmd, [...base, "--all"], { stdio: "inherit" })
      : spawnSync(cmd, [...base, ...(opts.slug ? [opts.slug] : [])], { stdio: "inherit" });

    process.exit(r.status ?? 0);
  });

program.parse(process.argv);